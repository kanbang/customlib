#ifndef EPSTRATEGYPATTER_H
#define EPSTRATEGYPATTER_H

#include <QDebug>

/**
 @note 程序的永恒主题：改变

 @note OO基础
        抽象
        封装
        多态
        继承
@defgroup   OO原则的目的都是为了系统维护，
            为了让后期维护代码修改比较少，这就需要封装、继承、多态。
            所有的设计模式都是为OO原则服务的。

@note OO原则
        封装变化
        多用组合，少用继承
        针对接口编程，不针对实现编程

 @note OO原则
        开闭原则
        一个软件实体应该对扩展开放，对修改关闭
        怎么实现开闭原则
        1、抽象
        2、多态
        3、继承
        4、接口

 @note 单一职责原则
        如果有多个原因去改变一个类，那么应该把这些引起变化的原因分开来，把这个类分成多个类，每个类只负责处理一种改变。
        当做出某种改变时，只需要修改负责处理该改变的类。
        因为当去改变一个具有多个职责的类时可能会影响该类的其他功能。
        像Strategy模式就是遵守单一职责原则。

    @note   一个类只负责一项职责

 @note 依赖倒转原则
        上层模块不应该依赖底层模块，它们都应该依赖于抽象
        抽象不应该依赖于细节，细节应该依赖于抽象
        抽象指的是接口或者抽象类，细节就是具体实现类

        依赖倒置原则的核心思想是面向接口编程。

 @note 里氏代换原则
        基类完全能够被子类替代而不影响模块的功能，主要体现在不要重载基类的一些基本功能函数
        is-a 的关系
        里氏代换是对开闭原则的扩展，它表明我们在创建基类的新的子类时，不应该改变基类的行为。

        子类可以扩展父类的功能，但是不能修改父类原有的功能
    @a  子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法
    @b  子类中可以增加自己特有的方法
    @c  当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松
    @d  当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

 @note 接口隔离原则
        不应该强迫客户端依赖于他们不会使用的接口

        建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。我们要为各个类建立专用的接口，
        而不要试图去建立一个庞大的接口供所有依赖它的类去调用。

        接口隔离与单一职责原则的区别
    @a  单一职责原则注重的是职责;而接口隔离原则注重对接口依赖的隔离。
    @b  单一职责原则主要是约束类，其次是接口和方法，它针对的是程序中的实现和细节，而接口隔离原则主要约束接口，主要针对抽象，针对程序整体框架的构建。

        采用接口隔离原则对接口进行约束时，要注意以下几点：
    @a  接口尽量小，但是要有限度，对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化，所以一定要适度。
    @b  为依赖接口的类定制服务，只暴露给调用的类需要的方法，类不需要的方法则隐藏起来，只有专注地为一个模块提供定制服务，才能建立最小的依赖关系
    @c  提高内聚，减少对外交互，使接口用最少的方法去完成最多的事情。

 @note 迪米特法则
        迪米特法则说的是一个对象应该对其它对象有尽可能少的了解。即只与你直接的朋友通信，不要跟陌生人说话。
        如果需要和陌生人通话，而你的朋友与陌生人是朋友，那么可以将你对陌生人的调用由你的朋友转发，使得某人只知道朋友，
        不知道陌生人。换言之，某人会认为他所调用的是朋友的方法。
        以下条件称为朋友的条件：
        当前对象本身。
        以参量的形式传入到当前对象方法中的对象。
        当前对象的实例变量直接引用的对象。
        当前对象的实例变量如果是一个聚集，那么聚集中的元素也都是朋友。
        当前对象所创建的对象。
        任何一个对象，如果满足上面的条件之一，就是当前对象的朋友，否则就是陌生人。

 @note 策略模式 定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用计算的客户
 */
class FlyBehavior;
class QuackBehavior;

class Duck
{
public:
    Duck();
    ~Duck(){}
    /**
     @brief 这个函数就是针对接口编程，因为这个函数只是调用了QuackBehavior::quack()这个接口。
            具体调用那个子类的quack，它并不知道。

            而如果把QuackBehavior::quack()写在Duck::quack()里面，那么这个Duck就定死了，这有两个坏处:
            @a  后期如果想修改鸭子的叫声，那么就得修改这个函数。
            @b  不能在运行的时候修改鸭子的叫声。
     */
    void quack();
    void setFly(FlyBehavior* fly);
    void setQuack(QuackBehavior* quack);
    void swim();
    /**
     @brief 并非Duck所有的子类都会飞。
        如果在超基类里面添加fly()和quack()函数，每当有新的子类出现，就要检查并可能需要覆盖这两个函数。
        如果有成千上万个不同的鸭子，那就意味着要实现成千上万给类，这样不好维护。
        如果有三种叫法，十种飞法，如果按照这种写法，那就将有30个类。
        但是如果分开来，就只需要13个类就可以了。
     */
    void fly();
    virtual void display();

private:
    FlyBehavior* _fly;
    QuackBehavior* _quack;
};

/**
 @brief 把飞这个动作分开来，这样就不仅仅可以用于鸭子的飞，以后如果要添加其他动物的飞的动作，
        也可以用。
 */
class FlyBehavior
{
public:
    ~FlyBehavior(){}
    virtual void fly() = 0;
};

class FlyWithWings : public FlyBehavior
{
public:
    void fly();
};

/**
 @brief 功能和 FlyBehavior 的功能相同。
 */
class QuackBehavior
{
public:
    virtual void quack() = 0;
};

class MuteQuack : public QuackBehavior
{
public:
    virtual void  quack();
};

class MallardDuck : public Duck
{
public:
    MallardDuck();
    void display();
};

class RedheadDuck : public Duck
{
public:
    RedheadDuck();
    void display();
};

#endif // EPSTRATEGYPATTER_H
